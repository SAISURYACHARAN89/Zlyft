<!DOCTYPE html>
<html>
  <head>
    <title>Andhra Pradesh Drone Flight Path Planner</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    />
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        height: 100vh;
      }
      #header {
        background-color: #2c3e50;
        color: white;
        padding: 10px 20px;
        text-align: center;
      }
      #container {
        display: flex;
        flex: 1;
      }
      #controls {
        width: 300px;
        padding: 20px;
        background-color: #f5f5f5;
        overflow-y: auto;
      }
      #map {
        flex: 1;
      }
      .form-group {
        margin-bottom: 15px;
      }
      label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }
      input,
      button {
        width: 100%;
        padding: 8px;
        box-sizing: border-box;
      }
      button {
        background-color: #3498db;
        color: white;
        border: none;
        cursor: pointer;
        padding: 10px;
        margin-top: 10px;
      }
      button:hover {
        background-color: #2980b9;
      }
      #path-info {
        margin-top: 20px;
        padding: 10px;
        background-color: #e8f4f8;
        border-radius: 5px;
      }
      .legend {
        padding: 10px;
        background: white;
        border-radius: 5px;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        line-height: 1.5;
      }
      .legend i {
        width: 18px;
        height: 18px;
        float: left;
        margin-right: 8px;
        opacity: 0.7;
      }
      .drone-icon {
        background-image: url("https://cdn-icons-png.flaticon.com/512/1163/1163477.png");
        background-size: contain;
        background-repeat: no-repeat;
        width: 40px;
        height: 40px;
        transform: rotate(0deg);
      }
      #animation-controls {
        margin-top: 15px;
        display: flex;
        justify-content: space-between;
      }
      #animation-speed {
        width: 60%;
      }
    </style>
  </head>
  <body>
    <div id="header">
      <h1>Andhra Pradesh Drone Flight Path Planner</h1>
    </div>
    <div id="container">
      <div id="controls">
        <div class="form-group">
          <label for="current-location">Current Location (Lat, Long):</label>
          <input
            type="text"
            id="current-location"
            placeholder="e.g., 17.6868, 83.2185"
          />
        </div>
        <div class="form-group">
          <label for="destination">Destination (Lat, Long):</label>
          <input
            type="text"
            id="destination"
            placeholder="e.g., 16.5062, 80.6480"
          />
        </div>
        <button id="calculate-path">Calculate Optimal Path</button>
        <button id="clear-path">Clear Path</button>

        <div id="path-info">
          <h3>Flight Information</h3>
          <p>Distance: <span id="distance">-</span> km</p>
          <p>Zones Crossed: <span id="zones-crossed">-</span></p>
          <p>Status: <span id="status">Ready</span></p>
        </div>

        <div id="animation-controls" style="display: none">
          <button id="start-animation">Start Drone Movement</button>
          <input type="range" id="animation-speed" min="1" max="10" value="5" />
        </div>

        <div class="legend">
          <h4>Legend</h4>
          <p><i style="background: red"></i> Red Zone (No-fly)</p>
          <p><i style="background: yellow"></i> Yellow Zone (Restricted)</p>
          <p><i style="background: green"></i> Safe Flight Path</p>
          <p><i style="background: blue"></i> Start/End Points</p>
          <p>
            <img
              src="https://cdn-icons-png.flaticon.com/512/1163/1163477.png"
              width="20"
            />
            Drone
          </p>
        </div>
      </div>
      <div id="map"></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-ant-path@1.3.0/dist/leaflet-ant-path.js"></script>
    <script>
      // Initialize the map centered on Andhra Pradesh
      const map = L.map("map").setView([16.5, 80.5], 8);

      // Add OpenStreetMap tiles
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution:
          '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
      }).addTo(map);

      // Define the no-fly zones (red zones) from the provided data
      const redZones = [
        {
          id: 1,
          name: "Visakhapatnam Naval Complex",
          city: "Visakhapatnam",
          latlng: [17.735, 83.295],
          radius: 2800,
          description: "Naval base and defense installations (mock)",
        },
        {
          id: 2,
          name: "Visakhapatnam Port Complex",
          city: "Visakhapatnam",
          latlng: [17.695, 83.275],
          radius: 2200,
          description: "Port area (mock)",
        },
        {
          id: 3,
          name: "Sriharikota Spaceport",
          city: "Sriharikota",
          latlng: [13.737, 80.23],
          radius: 3500,
          description: "ISRO launch site (mock)",
        },
        {
          id: 4,
          name: "Tirumala-Tirupati Zone",
          city: "Tirupati",
          latlng: [13.683, 79.42],
          radius: 2500,
          description: "Temple and pilgrimage area (mock)",
        },
        {
          id: 5,
          name: "Vijayawada Airport",
          city: "Vijayawada",
          latlng: [16.5304, 80.7968],
          radius: 2300,
          description: "Airport and surroundings (mock)",
        },
        {
          id: 6,
          name: "Rajahmundry Airport",
          city: "Rajahmundry",
          latlng: [17.1104, 81.8182],
          radius: 2100,
          description: "Airport and surroundings (mock)",
        },
        {
          id: 7,
          name: "Kadapa Airport",
          city: "Kadapa",
          latlng: [14.5094, 78.7728],
          radius: 1900,
          description: "Airport and surroundings (mock)",
        },
        {
          id: 8,
          name: "Kurnool Airport",
          city: "Kurnool",
          latlng: [15.7179, 78.0646],
          radius: 2000,
          description: "Airport and surroundings (mock)",
        },
        {
          id: 9,
          name: "Nandyal Power Plant",
          city: "Nandyal",
          latlng: [15.48, 78.48],
          radius: 1500,
          description: "Fictional power plant (mock)",
        },
        {
          id: 10,
          name: "Srikakulam Police HQ",
          city: "Srikakulam",
          latlng: [18.3, 83.9],
          radius: 1000,
          description: "Fictional police headquarters (mock)",
        },
        {
          id: 11,
          name: "Bhimavaram Government Complex",
          city: "Bhimavaram",
          latlng: [16.54, 81.52],
          radius: 120,
          description: "Fictional government complex (mock)",
        },
        {
          id: 12,
          name: "Bhimavaram Railway Station",
          city: "Bhimavaram",
          latlng: [16.545, 81.525],
          radius: 100,
          description: "Fictional railway station (mock)",
        },
        {
          id: 13,
          name: "Ongole Industrial Area",
          city: "Ongole",
          latlng: [15.5, 80.04],
          radius: 1800,
          description: "Heavy industry zone with drone restrictions",
        },
        {
          id: 22,
          name: "Nellore Industrial Area",
          city: "Nellore",
          latlng: [14.44, 79.99],
          radius: 1700,
          description: "Fictional industrial area (mock)",
        },
        {
          id: 23,
          name: "Ongole Central Town",
          city: "Ongole",
          latlng: [15.51, 80.05],
          radius: 1500,
          description: "Fictional central town (mock)",
        },
        {
          id: 24,
          name: "Chittoor Government Campus",
          city: "Chittoor",
          latlng: [13.21, 79.1],
          radius: 1600,
          description: "Fictional government campus (mock)",
        },
        {
          id: 25,
          name: "Eluru Medical Zone",
          city: "Eluru",
          latlng: [16.71, 81.11],
          radius: 1200,
          description: "Fictional medical zone (mock)",
        },
        {
          id: 26,
          name: "Kakinada Port Buffer",
          city: "Kakinada",
          latlng: [16.95, 82.24],
          radius: 1800,
          description: "Fictional port buffer (mock)",
        },
        {
          id: 27,
          name: "Anantapur Tech Park",
          city: "Anantapur",
          latlng: [14.68, 77.6],
          radius: 1400,
          description: "Fictional tech park (mock)",
        },
        {
          id: 28,
          name: "Guntur Railway Junction",
          city: "Guntur",
          latlng: [16.3, 80.44],
          radius: 1300,
          description: "Fictional railway junction (mock)",
        },
        {
          id: 29,
          name: "Bhimavaram Market Square",
          city: "Bhimavaram",
          latlng: [16.538, 81.518],
          radius: 150,
          description: "Fictional market square (mock)",
        },
      ];

      const yellowZones = [
        {
          id: 14,
          name: "Visakhapatnam Airport Yellow Zone",
          city: "Visakhapatnam",
          latlng: [17.7212, 83.2245],
          innerRadius: 5000,
          outerRadius: 12000,
          description: "8â€“12 km from airport perimeter (mock)",
        },
        {
          id: 15,
          name: "Vijayawada Airport Yellow Zone",
          city: "Vijayawada",
          latlng: [16.5304, 80.7968],
          innerRadius: 5000,
          outerRadius: 12000,
          description: "8â€“12 km from airport perimeter (mock)",
        },
        {
          id: 16,
          name: "Rajahmundry Airport Yellow Zone",
          city: "Rajahmundry",
          latlng: [17.1104, 81.8182],
          innerRadius: 5000,
          outerRadius: 12000,
          description: "8â€“12 km from airport perimeter (mock)",
        },
        {
          id: 17,
          name: "Tirupati Airport Yellow Zone",
          city: "Tirupati",
          latlng: [13.6329, 79.5433],
          innerRadius: 5000,
          outerRadius: 12000,
          description: "8â€“12 km from airport perimeter (mock)",
        },
        {
          id: 18,
          name: "Kadapa Airport Yellow Zone",
          city: "Kadapa",
          latlng: [14.5094, 78.7728],
          innerRadius: 5000,
          outerRadius: 12000,
          description: "8â€“12 km from airport perimeter (mock)",
        },
        {
          id: 19,
          name: "Kurnool Airport Yellow Zone",
          city: "Kurnool",
          latlng: [15.7179, 78.0646],
          innerRadius: 5000,
          outerRadius: 12000,
          description: "8â€“12 km from airport perimeter (mock)",
        },
        {
          id: 20,
          name: "Sriharikota Spaceport Yellow Zone",
          city: "Sriharikota",
          latlng: [13.737, 80.23],
          innerRadius: 5000,
          outerRadius: 12000,
          description: "8â€“12 km from spaceport perimeter (mock)",
        },
        {
          id: 21,
          name: "Visakhapatnam Naval Complex Yellow Zone",
          city: "Visakhapatnam",
          latlng: [17.735, 83.295],
          innerRadius: 5000,
          outerRadius: 12000,
          description: "8â€“12 km from naval base perimeter (mock)",
        },
      ];

      // Add red zones to the map
      redZones.forEach((zone) => {
        const circle = L.circle(zone.latlng, {
          color: "red",
          fillColor: "#f03",
          fillOpacity: 0.3,
          radius: zone.radius,
        }).addTo(map);

        circle.bindPopup(
          `<b>${zone.name}</b><br>${zone.city}<br>${zone.description}`
        );
      });

      // Add yellow zones to the map
      yellowZones.forEach((zone) => {
        // Outer yellow zone (8-12km)
        const outerCircle = L.circle(zone.latlng, {
          color: "yellow",
          fillColor: "#ff0",
          fillOpacity: 0.2,
          radius: zone.outerRadius,
        }).addTo(map);

        // Inner yellow zone (5-8km)
        const innerCircle = L.circle(zone.latlng, {
          color: "orange",
          fillColor: "#fa0",
          fillOpacity: 0.2,
          radius: zone.innerRadius,
        }).addTo(map);

        outerCircle.bindPopup(
          `<b>${zone.name}</b><br>${zone.city}<br>${zone.description}`
        );
        innerCircle.bindPopup(
          `<b>${zone.name} (Inner Restricted Area)</b><br>${zone.city}<br>${zone.description}`
        );
      });

      // Variables to store markers and path
      let startMarker, endMarker, flightPath, droneMarker, animationInterval;
      let currentPath = [];
      let currentAnimationStep = 0;

      // Custom drone icon
      const droneIcon = L.divIcon({
        className: "drone-icon",
        iconSize: [40, 40],
      });

      // Function to parse coordinate input
      function parseCoordinates(input) {
        const parts = input.split(",");
        if (parts.length !== 2) return null;

        const lat = parseFloat(parts[0].trim());
        const lng = parseFloat(parts[1].trim());

        if (isNaN(lat) || isNaN(lng)) return null;

        return [lat, lng];
      }

      // Function to calculate distance between two points in km
      function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Radius of the earth in km
        const dLat = deg2rad(lat2 - lat1);
        const dLon = deg2rad(lon2 - lon1);
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(deg2rad(lat1)) *
            Math.cos(deg2rad(lat2)) *
            Math.sin(dLon / 2) *
            Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      function deg2rad(deg) {
        return deg * (Math.PI / 180);
      }

      // Function to check if a point is in a red zone
      function isInRedZone(lat, lng) {
        for (const zone of redZones) {
          const distance = calculateDistance(
            lat,
            lng,
            zone.latlng[0],
            zone.latlng[1]
          );
          if (distance * 1000 <= zone.radius) {
            // Convert km to meters
            return zone;
          }
        }
        return false;
      }

      // Function to check if a point is in a yellow zone
      function isInYellowZone(lat, lng) {
        for (const zone of yellowZones) {
          const distance = calculateDistance(
            lat,
            lng,
            zone.latlng[0],
            zone.latlng[1]
          );
          if (
            distance * 1000 <= zone.outerRadius &&
            distance * 1000 > zone.innerRadius
          ) {
            return zone;
          }
        }
        return false;
      }

      // Function to calculate a path avoiding red zones
      function calculatePath(start, end) {
        document.getElementById("status").textContent = "Calculating path...";

        // Simple straight-line path (this would be replaced with a proper pathfinding algorithm)
        const path = [start, end];

        // Check if the straight line passes through any red zones
        let redZoneCrossed = false;
        let yellowZoneCrossed = false;
        let zonesCrossed = [];

        // Sample points along the path to check for zones
        const steps = 20;
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const lat = start[0] + t * (end[0] - start[0]);
          const lng = start[1] + t * (end[1] - start[1]);

          const redZone = isInRedZone(lat, lng);
          if (redZone && !zonesCrossed.includes(redZone.name)) {
            redZoneCrossed = true;
            zonesCrossed.push(redZone.name);
          }

          const yellowZone = isInYellowZone(lat, lng);
          if (yellowZone && !zonesCrossed.includes(yellowZone.name)) {
            yellowZoneCrossed = true;
            zonesCrossed.push(yellowZone.name);
          }
        }

        // If we cross a red zone, we need to find an alternative path
        if (redZoneCrossed) {
          // In a real implementation, we would use a proper pathfinding algorithm
          // For this demo, we'll just create a detour around the red zones

          // Find midpoint between start and end
          const midLat = (start[0] + end[0]) / 2;
          const midLng = (start[1] + end[1]) / 2;

          // Calculate detour point (this is a simplified approach)
          let detourLat = midLat;
          let detourLng = midLng;

          // Adjust the detour point based on the zones we're trying to avoid
          if (start[0] > 16 && end[0] > 16) {
            // If in northern AP
            detourLat += 0.2;
            detourLng -= 0.2;
          } else {
            // If in southern AP
            detourLat -= 0.2;
            detourLng += 0.2;
          }

          path.splice(1, 0, [detourLat, detourLng]);

          // Update zones crossed for the new path
          zonesCrossed = [];
          for (let i = 0; i < path.length - 1; i++) {
            const segmentStart = path[i];
            const segmentEnd = path[i + 1];

            for (let j = 0; j <= steps; j++) {
              const t = j / steps;
              const lat =
                segmentStart[0] + t * (segmentEnd[0] - segmentStart[0]);
              const lng =
                segmentStart[1] + t * (segmentEnd[1] - segmentStart[1]);

              const redZone = isInRedZone(lat, lng);
              if (redZone && !zonesCrossed.includes(redZone.name)) {
                zonesCrossed.push(redZone.name);
              }

              const yellowZone = isInYellowZone(lat, lng);
              if (yellowZone && !zonesCrossed.includes(yellowZone.name)) {
                zonesCrossed.push(yellowZone.name);
              }
            }
          }
        }

        // Calculate total distance
        let totalDistance = 0;
        for (let i = 0; i < path.length - 1; i++) {
          totalDistance += calculateDistance(
            path[i][0],
            path[i][1],
            path[i + 1][0],
            path[i + 1][1]
          );
        }

        // Update UI
        document.getElementById("distance").textContent =
          totalDistance.toFixed(2);
        document.getElementById("zones-crossed").textContent =
          zonesCrossed.length > 0 ? zonesCrossed.join(", ") : "None";

        if (redZoneCrossed) {
          document.getElementById("status").textContent =
            "Path found with detours around restricted areas";
        } else if (yellowZoneCrossed) {
          document.getElementById("status").textContent =
            "Path found through restricted areas (permission required)";
        } else {
          document.getElementById("status").textContent =
            "Optimal path found (no restrictions)";
        }

        return path;
      }

      // Function to animate drone movement along the path
      function animateDrone() {
        // Clear any existing animation
        if (animationInterval) {
          clearInterval(animationInterval);
        }
        if (droneMarker) {
          map.removeLayer(droneMarker);
        }

        // Show animation controls
        document.getElementById("animation-controls").style.display = "flex";

        // Create drone marker at start position
        droneMarker = L.marker(currentPath[0], {
          icon: droneIcon,
          rotationAngle: 0,
        }).addTo(map);

        // Get animation speed (1-10)
        const speed = parseInt(
          document.getElementById("animation-speed").value
        );
        const animationSteps = 100;
        const stepDuration = 1000 / speed; // Faster with higher speed

        currentAnimationStep = 0;

        animationInterval = setInterval(() => {
          if (currentAnimationStep >= animationSteps) {
            clearInterval(animationInterval);
            return;
          }

          // Calculate progress along the entire path
          const progress = currentAnimationStep / animationSteps;
          let accumulatedDistance = 0;
          let totalDistance = 0;

          // Calculate total path distance
          for (let i = 0; i < currentPath.length - 1; i++) {
            totalDistance += calculateDistance(
              currentPath[i][0],
              currentPath[i][1],
              currentPath[i + 1][0],
              currentPath[i + 1][1]
            );
          }

          // Find which segment we're in and how far along it
          let segmentStart,
            segmentEnd,
            segmentDistance,
            segmentProgress = 0;
          let distanceCovered = progress * totalDistance;

          for (let i = 0; i < currentPath.length - 1; i++) {
            segmentStart = currentPath[i];
            segmentEnd = currentPath[i + 1];
            segmentDistance = calculateDistance(
              segmentStart[0],
              segmentStart[1],
              segmentEnd[0],
              segmentEnd[1]
            );

            if (distanceCovered <= accumulatedDistance + segmentDistance) {
              segmentProgress =
                (distanceCovered - accumulatedDistance) / segmentDistance;
              break;
            }

            accumulatedDistance += segmentDistance;
          }

          // Calculate current position
          const lat =
            segmentStart[0] +
            segmentProgress * (segmentEnd[0] - segmentStart[0]);
          const lng =
            segmentStart[1] +
            segmentProgress * (segmentEnd[1] - segmentStart[1]);

          // Calculate bearing (direction)
          const bearing =
            (Math.atan2(
              segmentEnd[1] - segmentStart[1],
              segmentEnd[0] - segmentStart[0]
            ) *
              180) /
            Math.PI;

          // Update drone position and rotation
          droneMarker.setLatLng([lat, lng]);
          droneMarker.setIcon(
            L.divIcon({
              className: "drone-icon",
              html: `<img src="https://cdn-icons-png.flaticon.com/512/1163/1163477.png" style="transform: rotate(${
                bearing + 90
              }deg); width: 40px; height: 40px;">`,
              iconSize: [40, 40],
            })
          );

          // Center map on drone if it's going out of view
          map.panTo([lat, lng], { animate: false });

          currentAnimationStep++;
        }, stepDuration);
      }

      // Event listener for calculate path button
      document
        .getElementById("calculate-path")
        .addEventListener("click", function () {
          // Clear any existing path and animation
          if (flightPath) {
            map.removeLayer(flightPath);
          }
          if (animationInterval) {
            clearInterval(animationInterval);
          }
          if (droneMarker) {
            map.removeLayer(droneMarker);
          }

          // Hide animation controls until we have a path
          document.getElementById("animation-controls").style.display = "none";

          // Parse coordinates
          const startCoords = parseCoordinates(
            document.getElementById("current-location").value
          );
          const endCoords = parseCoordinates(
            document.getElementById("destination").value
          );

          if (!startCoords || !endCoords) {
            alert(
              "Please enter valid coordinates in the format 'latitude, longitude'"
            );
            return;
          }

          // Check if start or end is in a red zone
          const startRedZone = isInRedZone(startCoords[0], startCoords[1]);
          const endRedZone = isInRedZone(endCoords[0], endCoords[1]);

          if (startRedZone) {
            alert(
              `Cannot start flight: Current location is in a red zone (${startRedZone.name})`
            );
            return;
          }

          if (endRedZone) {
            alert(
              `Cannot fly to destination: Destination is in a red zone (${endRedZone.name})`
            );
            return;
          }

          // Remove existing markers
          if (startMarker) map.removeLayer(startMarker);
          if (endMarker) map.removeLayer(endMarker);

          // Add new markers
          startMarker = L.marker(startCoords, {
            icon: L.divIcon({
              className: "start-marker",
              html: "ðŸ›«",
              iconSize: [30, 30],
            }),
          })
            .addTo(map)
            .bindPopup("Start Point");

          endMarker = L.marker(endCoords, {
            icon: L.divIcon({
              className: "end-marker",
              html: "ðŸ›¬",
              iconSize: [30, 30],
            }),
          })
            .addTo(map)
            .bindPopup("Destination");

          // Calculate and display path
          currentPath = calculatePath(startCoords, endCoords);

          // Add the path to the map with animation
          flightPath = L.polyline(currentPath, {
            color: "green",
            weight: 5,
            opacity: 0.7,
            dashArray: "10, 10",
          }).addTo(map);

          // Fit the map to show the entire path
          map.fitBounds(flightPath.getBounds());

          // Show animation controls
          document.getElementById("animation-controls").style.display = "flex";
        });

      // Event listener for start animation button
      document
        .getElementById("start-animation")
        .addEventListener("click", function () {
          if (currentPath && currentPath.length > 0) {
            animateDrone();
          }
        });

      // Event listener for clear path button
      document
        .getElementById("clear-path")
        .addEventListener("click", function () {
          if (flightPath) {
            map.removeLayer(flightPath);
            flightPath = null;
          }
          if (startMarker) {
            map.removeLayer(startMarker);
            startMarker = null;
          }
          if (endMarker) {
            map.removeLayer(endMarker);
            endMarker = null;
          }
          if (droneMarker) {
            map.removeLayer(droneMarker);
            droneMarker = null;
          }
          if (animationInterval) {
            clearInterval(animationInterval);
            animationInterval = null;
          }

          // Hide animation controls
          document.getElementById("animation-controls").style.display = "none";

          // Reset UI
          document.getElementById("distance").textContent = "-";
          document.getElementById("zones-crossed").textContent = "-";
          document.getElementById("status").textContent = "Ready";
        });
    </script>
  </body>
</html>
